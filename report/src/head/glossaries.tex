\setglossarystyle{katie}

\newglossary*{latin}{Latin Symbols}
\newglossary*{greek}{Greek Symbols}
\newglossary*{noprint}{Names}

\makeglossaries
\addlat[pa]{pa}{\ensuremath{p\ut{a}}}{Atmospheric pressure}
\addlatnumbered{Vt}{\ensuremath{V\ut{tXX}}}{Common tank volume (parallel system}
\addlatnumbered{qdt}{\ensuremath{q\ut{d,tXX}}}{Mass flow rate through common tank discharge valve (parallel system)}
\addgrknumbered{rho}{rho}{\ensuremath{\vc{\rho_{XX}}}}{Coefficients mapping mass flow across common tank discharge valve to its pressure differential (parallel system)}
\addlatnumbered{ut}{\ensuremath{u\ut{tXX}}}{Position of common tank discharge valve (parallel system)}
\addlatnumbered{ps}{\ensuremath{p\ut{sXX}}}{Compressor suction pressure}
% \addlatnumbered{pd}{\ensuremath{p\ut{dXX}}}{Compressor discharge pressure}
\addgrknumbered{omegac}{omegac}{\ensuremath{\omega\ut{cXX}}}{Rotational speed of the compressor}
\addlatnumbered{qr}{\ensuremath{q\ut{rXX}}}{Mass flow rate through recycle valve}
\addlat{a}{\ensuremath{a}}{Speed of sound (\u{340}{m\per s})}
\addlatnumbered{Vs}{\ensuremath{V\ut{sXX}}}{Compressor suction tank volume}
\addlatnumbered{Vd}{\ensuremath{V\ut{dXX}}}{Compressor discharge tank volume}
\addlatnumbered{qs}{\ensuremath{q\ut{sXX}}}{Mass flow rate through suction valve}
\addlat{A}{\ensuremath{A}}{Cross-sectional piping area after compressor}
\addlatnumbered{lc}{\ensuremath{l\ut{cXX}}}{Duct length after compressor}
\addlatnumbered{Jcomp}{\ensuremath{J\ut{compXX}}}{Compressor inertia}
\addgrknumbered{beta}{beta}{\ensuremath{\vc{\beta_{XX}}}}{Coefficients mapping steady-state motor torque to rotational speed and mass flow of compressor}
\addgrknumbered{taur}{taur}{\ensuremath{\tau\ut{rXX}}}{Time constant of recycle valve}
\addlatnumbered{urSP}{\ensuremath{u\ut{r,SPXX}}}{Set point of recycle valve}
\addgrknumbered{gamma}{gamma}{\ensuremath{\vc{\gamma_{XX}}}}{Coefficients mapping mass flow through suction valve to its pressure differential}
\addgrknumbered{delta}{delta}{\ensuremath{\vc{\delta_{XX}}}}{Coefficients mapping mass flow through recycle valve to its pressure differential}
\addlatnumbered{us}{\ensuremath{u\ut{sXX}}}{Position of suction valve}
\addlatnumbered{pin}{\ensuremath{p\ut{inXX}}}{Pressure upstream of compressor}
\addlatnumbered{pout}{\ensuremath{p\ut{outXX}}}{Pressure downstream of compressor}
\addlat{m}{\ensuremath{m}}{Move horizon of controller}
\addlat{J}{\ensuremath{J}}{MPC controller cost function}
\addgrknumbered{alpha}{alpha}{\ensuremath{\vc{\alpha_{XX}}}}{Coefficients mapping compressor pressure ratio to compressor speed and mass flow}

% Compressor mass flow
% \addlatnumbered{qc}{\ensuremath{qc}}{Mass flow rate through compressor}
\newglossaryentry{qc}
{
  name={\ensuremath{q\ut{c}}},
  user1={\ensuremath{q\ut{c,1}}},
  user2={\ensuremath{q\ut{c,2}}},
  user3={\ensuremath{q\ut{c,SL}}},
  description={Mass flow rate through compressor},
  sort={qc},
  type={latin}
}
% Compressor pressure ratio
\newglossaryentry{Pi}
{
  name={\ensuremath{\Pi}},
  user1={\ensuremath{\Pi\ut{ss}}},
  user2={\ensuremath{\Pi\ut{SL}}},
  description={Compressor pressure ratio ($\tfrac{\gentry{pd}}{\gentry{ps}}$).},
  sort={Pi},
  type={greek}
}

% Tank pressure
\newglossaryentry{pt}
{
   name={\ensuremath{p\ut{t}}},
  user1={\ensuremath{p\ut{t,k}}},
  user2={\ensuremath{p\ut{t,k+i}}},
  sort={pt},
  description={Common tank pressure (parallel system)},
  type={latin}
}
% \addlatnumbered{pt}{\ensuremath{p\ut{tXX}}}{Common tank pressure (parallel system)}

% Cost function
\addlatfork[Jpcen]{Jpcen}{\ensuremath{J\ut{p,XX}^\text{cen}}}{Centralized cost function of parallel system}
\addlatfork[Jpcoop]{Jpcoop}{\ensuremath{J\ut{p,XX}^\text{coop}}}{Distributed, cooperative cost function of parallel system}
\addlatfork[Jpncoop]{Jpncoop}{\ensuremath{J\ut{p,XX}^\text{nc}}}{Distributed, non-cooperative cost function of parallel system}
\addlatfork[Jscen]{Jscen}{\ensuremath{J\ut{s,XX}^\text{cen}}}{Centralized cost function of serial system}
\addlatfork[Jscoop]{Jscoop}{\ensuremath{J\ut{s,XX}^\text{coop}}}{Distributed, cooperative cost function of serial system}
\addlatfork[Jsncoop]{Jsncoop}{\ensuremath{J\ut{s,XX}^\text{nc}}}{Distributed, non-cooperative cost function of serial system}

% Weighted outputs/inputs
\newglossaryentry{ywtd}
{
   name={\ensuremath{\vc{y}_{\text{p},k}^{(\cdot)}}},
  user1={\ensuremath{\vc{y}_{\text{p},k}^\text{cen}}},
  user2={\ensuremath{\vc{y}_{\text{p},k}^\text{co,1}}},
  user3={\ensuremath{\vc{y}_{\text{p},k}^\text{co,2}}},
  user4={\ensuremath{\vc{y}_{\text{p},k}^\text{nc,1}}},
  user5={\ensuremath{\vc{y}_{\text{p},k}^\text{nc,2}}},
  user6={\ensuremath{\vc{y}_{\text{s},k}^\text{cen}}},
  user7={\ensuremath{\vc{y}_{\text{s},k}^\text{co,1}}},
  user8={\ensuremath{\vc{y}_{\text{s},k}^\text{co,2}}},
  user9={\ensuremath{\vc{y}_{\text{s},k}^\text{nc,1}}},
 user10={\ensuremath{\vc{y}_{\text{s},k}^\text{nc,2}}},
 user11={\ensuremath{\vc{y}_{\text{s},k}^{(\cdot)}}},
 plural={\ensuremath{\vc{y}_{\text{p},k+i}^\text{cen}}},
  description={Weighted inputs},
  type={noprint}
}
\newglossaryentry{uwtd}
{
   name={\ensuremath{\vc{u}_{\text{p},k}^{(\cdot)}}},
  user1={\ensuremath{\vc{u}_{\text{p},k}^\text{cen}}},
  user2={\ensuremath{\vc{u}_{\text{p},k}^\text{co,1}}},
  user3={\ensuremath{\vc{u}_{\text{p},k}^\text{co,2}}},
  user4={\ensuremath{\vc{u}_{\text{p},k}^\text{nc,1}}},
  user5={\ensuremath{\vc{u}_{\text{p},k}^\text{nc,2}}},
  user6={\ensuremath{\vc{u}_{\text{s},k}^\text{cen}}},
  user7={\ensuremath{\vc{u}_{\text{s},k}^\text{co,1}}},
  user8={\ensuremath{\vc{u}_{\text{s},k}^\text{co,2}}},
  user9={\ensuremath{\vc{u}_{\text{s},k}^\text{nc,1}}},
 user10={\ensuremath{\vc{u}_{\text{s},k}^\text{nc,2}}},
 user11={\ensuremath{\vc{u}_{\text{s},k}^{(\cdot)}}},
 plural={\ensuremath{\vc{u}_{\text{p},k+i}^\text{cen}}},
  description={Weighted inputs},
  type={noprint}
}
\newglossaryentry{ywts}
{
   name={\ensuremath{W\ut{p,y}}},
  user1={\ensuremath{W\ut{p,y}^\text{cen}}},
  user2={\ensuremath{W\ut{p,y}^\text{co,1}}},
  user3={\ensuremath{W\ut{p,y}^\text{co,2}}},
  user4={\ensuremath{W\ut{p,y}^\text{nc,1}}},
  user5={\ensuremath{W\ut{p,y}^\text{nc,2}}},
  user6={\ensuremath{W\ut{s,y}^\text{cen}}},
  user7={\ensuremath{W\ut{s,y}^\text{co,1}}},
  user8={\ensuremath{W\ut{s,y}^\text{co,2}}},
  user9={\ensuremath{W\ut{s,y}^\text{nc,1}}},
 user10={\ensuremath{W\ut{s,y}^\text{nc,2}}},
  description={Weights on outputs},
  type={noprint}
}
\newglossaryentry{uwts}
{
   name={\ensuremath{W\ut{p,u}}},
  user1={\ensuremath{W\ut{p,u}^\text{cen}}},
  user2={\ensuremath{W\ut{p,u}^\text{co,1}}},
  user3={\ensuremath{W\ut{p,u}^\text{co,2}}},
  user4={\ensuremath{W\ut{p,u}^\text{nc,1}}},
  user5={\ensuremath{W\ut{p,u}^\text{nc,2}}},
  user6={\ensuremath{W\ut{s,u}^\text{cen}}},
  user7={\ensuremath{W\ut{s,u}^\text{co,1}}},
  user8={\ensuremath{W\ut{s,u}^\text{co,2}}},
  user9={\ensuremath{W\ut{s,u}^\text{nc,1}}},
 user10={\ensuremath{W\ut{s,u}^\text{nc,2}}},
  description={Weights on outputs},
  type={noprint}
}

% Outputs
\addglsunumbered{sd}{sd}{\ensuremath{\mathit{SD}_{XX}}}{Surge distance}{latin}
\addglsunumbered{scd}{scd}{\ensuremath{\mathit{SCD}_{XX}}}{Surge control distance}{latin}


% Modeling/singlecomp
\addlatnumbered[Td]{torque}{\ensuremath{T\ut{dXX}}}{Torque input to compressor}
\addlatnumbered{qd}{\ensuremath{q\ut{dXX}}}{Mass flow rate through discharge valve}
\addlatnumbered{ur}{\ensuremath{u\ut{rXX}}}{Recycle valve opening}

\addlatnumbered[Tc]{airtorque}{\ensuremath{T\ut{cXX}}}{Torque on compressor resulting from air compression}
\addlatnumbered[xn]{nominalstate}{\ensuremath{\vc{x}\ut{nXX}}}{Nominal state vector for a single compressor}
\addlatnumbered[yn]{yn}{\ensuremath{\vc{y}\ut{nXX}}}{Nominal output vector for a single compressor}
\addlatnumbered[un]{un}{\ensuremath{\vc{u}\ut{nXX}}}{Nominal input vector for a single compressor}
\addlatnumbered[fn]{nominalderiv}{\ensuremath{\vc{f}\ut{nXX}}}{Nominal state derivative vector for a single compressor}
\addglsunumbered{epsilon}{epsilon}{\ensuremath{\vc{\varepsilon}\ut{XX}}}{Coefficients mapping mass flow through discharge valve to its pressure differential}{greek}
\addlatnumbered[ud]{ud}{\ensuremath{u\ut{dXX}}}{Position of discharge valve}
\addlatnumbered[pd]{pd}{\ensuremath{p\ut{dXX}}}{Compressor discharge pressure}

% Modelling/parallel
\addglswk{xp}{parstate}{\ensuremath{\vc{x}_{\text{p}XX}}}{Parallel system state vector}{latin}
\addglswk{yp}{parout}{\ensuremath{\vc{y}_{\text{p}XX}}}{Parallel system output vector}{latin}
\addglswk{up}{parin}{\ensuremath{\vc{u}_{\text{p}XX}}}{Parallel system input vector}{latin}
\addglswk{fp}{parderiv}{\ensuremath{\vc{f}_{\text{p}XX}}}{Parallel system state derivative vector}{latin}

% modelling/serial
\addglswk{xs}{serialstate}{\ensuremath{\vc{x}_{\text{s}XX}}}{Serial system state vector}{latin}
\addglswk{ys}{serialout}  {\ensuremath{\vc{y}_{\text{s}XX}}}{Serial system output vector}{latin}
\addglswk{us}{serialin}   {\ensuremath{\vc{u}_{\text{s}XX}}}{Serial system input vector}{latin}
\addglswk{fs}{serialderiv}{\ensuremath{\vc{f}_{\text{s}XX}}}{Serial system state derivative vector}{latin}

% MPC
\newglossaryentry{Delta}
{
  name={\ensuremath{\Delta\left( \cdot \right)}},
  user1={\ensuremath{\Delta}},
  description={Difference in $\left( \cdot \right)$ relative to its value at the linearization point},
  sort={Delta},
  type={greek}
}
\addlatfork[xk]{xhat}{\ensuremath{\vc{\hat{x}}_{XX}}}{State estimate at time step $k$}
\addlatfork[uk]{ucurr}{\ensuremath{\vc{u}_{XX}}}{Input applied at time step $k$}
\addlatfork[yk]{ycurr}{\ensuremath{\vc{y}_{XX}}}{Output at time step $k$}

% discretized derivative
\addlatfork[fk]{fcurr}{\ensuremath{\vc{f}_{\text{d},XX}}}{Discretized system derivative at time step $k$}

\newglossaryentry{sys-mats}
{
  name={\ensuremath{A_k,\ B_k,\ C_k}},
  user1={\ensuremath{A_k}},
  user2={\ensuremath{B_k}},
  user3={\ensuremath{C_k}},
  user4={\ensuremath{A_k=A_k\left( \gentry{xhat},\gentrymo{ucurr} \right),\ B_k=B_k\left( \gentry{xhat},\gentrymo{ucurr} \right)} \text{and} \ensuremath{C_k=C_k\left( \gentry{xhat},\gentrymo{ucurr} \right)}},
  description={Linearized, discretized model matrices},
  sort={Ak Bk Ck}
  type={latin}
}
\newglossaryentry{augsys-mats}
{
  name={\ensuremath{A_k^a,\ B_k^a,\ C_k^a}},
  user1={\ensuremath{A_k^a}},
  user2={\ensuremath{B_k^a}},
  user3={\ensuremath{C_k^a}},
  user4={\ensuremath{A_k^a=A_k^a\left( \gentry{xhat},\gentrymo{ucurr} \right),\ B_k^a=B_k^a\left( \gentry{xhat},\gentrymo{ucurr} \right)} \text{and} \ensuremath{C_k^a=C_k^a\left( \gentry{xhat},\gentrymo{ucurr} \right)}},
  user5={\ensuremath{A_k^a}, \ensuremath{B_k^a} and \ensuremath{C_k^a}},
  description={Linearized, discretized model matrices},
  sort={Aka Bka Cka}
  type={latin}
}

\addlat[p]{p}{\ensuremath{p}}{Prediction horizon}
\addlatfork[xaug]{xaug}{\ensuremath{\Delta \vc{\hat{x}}_{XX}^a}}{Augmented state estimate at time step $k$}
\addlatfork[Bdelay]{Bdelay}{\ensuremath{B_{XX}^\text{delay}}}{Columns of \gentryii{sys-mats} corresponding to delayed inputs}
\addlatfork[Bnodelay]{Bnodelay}{\ensuremath{B_{XX}^\text{nodelay}}}{Columns of \gentryii{sys-mats} corresponding to non-delayed inputs}
\addlat[Adelay]{Adelay}{\ensuremath{A^\text{delay}}}{Component of the augmented $A$ matrix multiplied by the delayed states}
\addlatfork[udel]{udel}{\ensuremath{\vc{u}^{\text{delay}}_{XX}}}{Delayed recycle input states at time step $k$}
\addlatfork[ek]{integrator}{\ensuremath{\vc{e}_{XX}}}{Integrator states of MPC controller}
\addlat[Baug]{Baug}{\ensuremath{B^\text{aug}}}{Component of the augmented $B$ matrix that outputs the delayed states}
\addlatfork[uk]{deltau}{\ensuremath{\Delta \vc{u}^\text{a}_{XX}}}{Change in input applied to the system at time step $k$}

% MPC/optimization
\addlatdelta[Uk]{Uk}{\ensuremath{U_k}}{Optimal input sequence, stacked over the move horizon, at time step $k$}
\addlatdelta[Yk]{Yk}{\ensuremath{Y_k}}{Predicted output sequence, stacked over the prediction horizon, at time step $k$}
\addlatdelta[Yrefk]{Yrefk}{\ensuremath{Y^\text{ref}_k}}{Reference output sequence, stacked over the prediction horizon, at time step $k$}
\addlatdelta[Uother]{Uother}{\ensuremath{U^\text{ot}_k}}{Input sequence from other distributed controller, stacked over the move horizon, at time step $k$}
\newglossaryentry{weights}
{
  sort={Q R},
  name={\ensuremath{Q,\ R}},
  user1={\ensuremath{Q}},
  user2={\ensuremath{R}},
  user3={\ensuremath{Q} \text{and} \ensuremath{R}},
  description={Weighting terms applied to inputs and outputs, respectively},
  type={latin}
}


\addlat[ts]{ts}{\ensuremath{t\ut{s}}}{Sample rate}

\newglossaryentry{prediction-matrices}
{
  name={\ensuremath{S_{U_k}}, \ensuremath{S_{x_k}}, \ensuremath{S_{f_k}}},
  user1={\ensuremath{S_{U_k}}},
  user2={\ensuremath{S_{x_k}}},
  user3={\ensuremath{S_{f_k}}},
  user4={\ensuremath{S_{U_k}}, \ensuremath{S_{x_k}} \text{and} \ensuremath{S_{f_k}}},
  description={Prediction matrices for \gentryi{Delta}\gentry{Yk}},
  sort={SUk Sxk Sfk},
  type={latin}
}

\addlat[SUother]{prediction-uother}{\ensuremath{S_{\gentry{Uother}}}}{Prediction matrix giving effect of the other sub-controller's inputs on \gentryi{Yk}}

% observer
\addlatnumbered[M]{M}{\ensuremath{MXX}}{Static observer gain}

% not to print
\newglossaryentry{uraug}
{
  name={\ensuremath{\vc{u}_{\text{r},k-1}^\text{a}}},
  description={recycle valve value at linearization},
  type={noprint}
}
